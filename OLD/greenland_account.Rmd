---
title: "Constructing a Demographic Account, with Lexis Triangles, for Greenland"
author: "John Bryant"
institute: Bayesian Demography Limited
date: "17/11/2019"
output: pdf_document
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this note we show how to arrange data on population, births, deaths, and migration for Greenland into a demographic account. The raw data does not specify Lexis triangles, so the function for constructing the account randomly allocates events to triangles. We show how, thanks to the Lexis triangles, we are able to switch between different views of the data.

To run the code, we need the *R* packages listed below. The package **dembase** can be obtained from [GitHub](https://github.com/statisticsnz/dembase). All the rest can be obtained from CRAN. We are hoping to replace **dembase** with a collection of new packages, with an improved interface, over the course of 2020. The repositories for the new packages under development are [here](https://github.com/bayesiandemography). Once the packages are ready, we will release them on to CRAN.

```{r}
library(dembase)
library(readr)
library(tidyr)
library(dplyr)
library(ggplot2)
```


# Preparing Raw Data

We start by reading the raw data, which we downloaded from the Statbank Greenland website on 17 November 2019.

We will use the following age categories for all datasets other than births:

```{r}
levels_age <- c(0:99, "100+")
```


## Population

We read in the data on population data, and reformat it. Package **dembase** assumes that year labels are constructed using the "year to" convention, where, for instance, the exact time "2010" refers to 31 December 2010. The Greenland data follow a "year from" convention. We can convert between the two by subtracting 1 from the time variable. (This is horribly confusing: the packages replacing **dembase** will handle year labels better.)

```{r}
popn_df <- read_csv("BEXST1.csv",
                 skip = 2,
                 n_max = 200) %>%
    select(age,
           sex = gender,
           `1977`:`2019`) %>%
    gather(key = time, 
           value = count,
           `1977`:`2019`) %>%
    mutate(age = factor(age, levels = levels_age)) %>%
    mutate(sex = factor(sex, 
                        levels = c("Women", "Men"), 
                        labels = c("Female", "Male"))) %>%
    mutate(time = as.integer(time),
           time = time - 1)
```

We format the data for births, deaths, and international migration in the same way, though we don't have to make any adjustments to the time variable in these cases, since they refer to periods rather than exact times.

```{r}
births_df <- read_csv("BEXBBL3.csv",
                   skip = 2,
                   n_max = 72) %>%
    select(age,
           sex = gender,
           `1973`:`2018`) %>%
    gather(key = time,
           value = count,
           `1973`:`2018`) %>%
    mutate(sex = factor(sex,
                        levels = c("Girls", "Boys"),
                        labels = c("Female", "Male")))
```

```{r}
deaths_df <- read_csv("BEXBBDM1.csv",
                   skip = 2,
                   n_max = 200) %>%
    select(age,
           sex = gender,
           `1977`:`2018`) %>%
    gather(key = time,
           value = count,
           `1977`:`2018`) %>%
    mutate(age = factor(age, levels = levels_age)) %>%
    mutate(sex = factor(sex,
                        levels = c("Women", "Men"),
                        labels = c("Female", "Male")))
```

```{r}
migration_df <- read_csv("BEXBBIU2.csv",
                      skip = 2,
                      n_max = 400) %>%
    select(age,
           sex = gender,
           migration,
           `1993`:`2018`) %>%
    gather(key = time,
           value = count,
           `1993`:`2018`) %>%
    mutate(age = factor(age, levels = levels_age)) %>%
    mutate(sex = factor(sex,
                        levels = c("Women", "Men"),
                        labels = c("Female", "Male")))
```

# Constructing Demographic Arrays

In package **dembase**, demographic accounts are assembled out of demographic arrays. A demographic array is a standard multiway array, with some extra metadata. Function `Counts`, which is used to construct the demographic arrays, can infer most of the metadata from the dimnames of the input data, but needs some help in deciding whether the times refer to points or intervals. We restrict the demographic arrays and account to the period 1992-2018, since this is the period for which international migration data is available.

```{r}
popn <- popn_df %>%
    filter(time %in% 1992:2018) %>%
    dtabs(count ~ age + sex + time) %>%
    Counts(dimscales = c(time = "Points"))
```

Calling `summary` on demographic array `popn` shows the range of numeric values, plus the metadata.

```{r}
summary(popn)
```

Calling `plot` on `popn` shows bar graphs of the marginal totals.

```{r}
plot(popn)
```

The remaining demographic arrays are constructed in a similar way to `popn`.

```{r}
births <- births_df %>%
    filter(time %in% 1993:2018) %>%
    dtabs(count ~ age + sex + time) %>%
    Counts(dimscales = c(time = "Intervals"))
plot(births)
```


```{r}
deaths <- deaths_df %>%
    filter(time %in% 1993:2018) %>%
    dtabs(count ~ age + sex + time) %>%
    Counts(dimscales = c(time = "Intervals"))
plot(deaths)
```

```{r}
immigration <- migration_df %>%
    filter(migration == "Immigrations") %>%
    dtabs(count ~ age + sex + time) %>%
    Counts(dimscales = c(time = "Intervals"))
plot(immigration)
```


```{r}
emigration <- migration_df %>%
    filter(migration == "Emigrations") %>%
    dtabs(count ~ age + sex + time) %>%
    Counts(dimscales = c(time = "Intervals"))
plot(emigration)
```

# Constructing a Demographic Account

Now that we have all the demographic arrays, we can construct a demographic account. There are two types of demographic accounts: "movements" accounts and "transitions" accounts. Our data are events, rather than transitions, so we construct a movements account.

```{r}
account <- Movements(population = popn,
                     births = births,
                     entries = list(immigration = immigration),
                     exits = list(deaths = deaths, 
                                  emigration = emigration))
```

Calling `summary` on the account shows annual population numbers and associated increments and decrements to the population. As can be seen at the bottom of the summary, the account is not internally consistent. The account contains cells that do not conform to the basic accounting identity that population at the end of each period equals population at the beginning plus entries minus exits. We could try to adjust the numbers to make the account consistent, using, for instance, function `estimateAccount` in package **demest**. We don't attempt to do that here, however, as our main focus is on Lexis triangles.

```{r}
summary(account)
```

# Lexis Triangles and Different Views of the Events Data

We can extract deaths from the account using function `components`.

```{r}
deaths_tri <- components(account, "deaths")
```

When we summarise `deaths_tri` we find that it has acquired a new "triangle" dimension:

```{r}
summary(deaths_tri)
```

Lexis triangles can be used to distinguish between cohorts, in data on events that is cross-classified by age and time. An event belongs to the upper Lexis triangle if the person experiencing the event was already aged $a$ at the start of the period; otherwise the event belongs to the lower triangle. In Figure 1, for instance, event B belongs to the upper triangle, and event A belongs to the lower triangle.

![Lexis triangles](fig_lexis.pdf)

Demographic accounts in package **dembase** need to specify which Lexis triangle each event belongs to. Since we did not have a "triangle" dimension in the original data, function `Movements` has randomly assigned events to triangles. Here is a small subset of values, with the Lexis triangles:

```{r}
deaths_tri %>% 
    subarray(sex == "Female") %>%
    subarray(age < 5) %>%
    subarray(time < 1998)
```

When our data contains Lexis triangles, in addition to age and time, we can "rotate" the age time plan, to get different views of the data. We start with the original view, where deaths are arranged by age and time.

```{r}
deaths_tri %>%
    subarray(age %in% seq(0, 80, 10)) %>%
    collapseDimension(dimension = "triangle") %>%
    as.data.frame() %>%
    mutate(age = paste("Age", age)) %>%
    ggplot(aes(x = time, y = count, color = sex)) +
    facet_wrap(vars(age)) +
    geom_line() +
    ggtitle("Deaths by age, time, and sex")
```

Now we rotate to a cohort-time format. (We need to drop the oldest age group, since function `rotateAgeTime` does not allow open age groups.)

```{r}
deaths_cohort_time <- deaths_tri %>%
    subarray(age < 100) %>%
    rotateAgeTime(to = "cohort-time")
```

When we call `summary` on the rotated dataset, we find that the "age" dimension has been replaced by a "cohort" dimension.

```{r}
summary(deaths_cohort_time)
```

We can now graph deaths over time, for selected birth cohorts.

```{r}
deaths_cohort_time %>%
    subarray(cohort %in% seq(1900, 2010, 10)) %>%
    collapseDimension(dimension = "triangle") %>%
    as.data.frame() %>%
    mutate(cohort = paste("Cohort born in", cohort)) %>%
    ggplot(aes(x = time, y = count, color = sex)) +
    facet_wrap(vars(cohort)) +
    geom_line() +
    ggtitle("Deaths by cohort, time, and sex")
```

Next we rotate the original data to a cohort-age view.

```{r}
deaths_cohort_age <- deaths_tri %>%
    subarray(age < 100) %>%
    rotateAgeTime(to = "cohort-age")
summary(deaths_cohort_age)
```

We graph deaths over age, for selected cohorts.

```{r}
deaths_cohort_age %>%
    subarray(cohort %in% seq(1900, 2000, 10)) %>%
    collapseDimension(dimension = "triangle") %>%
    as.data.frame() %>%
    mutate(cohort = paste("Cohort born in", cohort)) %>%
    ggplot(aes(x = age, y = count, color = sex)) +
    facet_wrap(vars(cohort)) +
    geom_line() +
    ggtitle("Deaths by cohort, age, and sex")
```


Function `Movements` has also added triangle dimensions to the births, immigration, and emigration series, and similar transformations can be carried out with them.